순환적인 방법으로 피보나치 수열을 호출하였을 때 함수가 중복되어 호출되는 것을
확인할 수 있도록 각 함수의 매개변수별 호출 빈도를 측정해 출력하라
> 순환 - 도전문제 - cg01

자료형이 long인 경우 가장 큰 피보나치 수를 구하라
> 순환 - 도전문제 - cg02

문자열의 내용을 반대로 바꾸는 순환적인 함수 reverse()를 구현하라
> 순환 - 도전문제 - cg03

다음의 수식과 같이 순환적으로 표현되는 Ackermann 함수를 구현하고 테스트한다
a(0, n)=1
a(1, 0)=2
a(m, 0)=m+2, if m>1
a(m, n)=a(a(m-1), n), n-1), if m>0 and n>0
> 순환 - 도전문제 - cg04

다음과 같은 모양을 출력하는 순환적인 함수를 작성하라
-------------------X------------------
---------X-------------------X--------
----X---------X---------X---------X---
-X----X----X----X----X----X----X----X-
> 순환 - 도전문제 - cg05

다음을 계산하는 순환적인 프로그램을 작성하라
1+2+3+...+n
> 순환 - 연습문제 - ex01

다음을 계산하는 순환적인 프로그램을 작성하라
1+1/2+1/3+...+1/n
> 순환 - 연습문제 - ex02

이진트리 클래스의 구현
연산 추가
(1) 이진트리가 완전 이진트리인지를 검사하는 연산
(2) 임의의 node의 레벨을 구하는 연산을 구현한다, 만약 node가 트리 안에 있지 않으면 0을 반환한다.
(3) 이진트리의 모든 노드에서 왼쪽 서브트리와 오른쪽 서브트리의 높이의 차이가 2보다 작으면 이 트리를 균형잡혀있다라고 한다.
    현재 이진트리가 균형 잡혀 있는지를 검사하는 다음 연산을 구현한다.
(4) 이진트리에서 경로의 길이를 루트에서부터 모든 자식 노드까지의 경로의 길이의 합이라고 하자. 경로의 길이를 구하는 연산을 구현한다
(5) 이진트리를 좌우로 대칭시키는 연산을 구현한다
> 트리 & 이진탐색트리 - project01

이진 탐색 트리의 탐색 연산을 트리 클래스에서 구현했고 노드 클래스에서도 구현해 보았다.
트리의 각 노드들을 모두 자신을 루트로 하는 서브트리를 대표한다고 보면 많은 트리의 연산들을 노드에서 구현할 수 있다.
8장의 프로그램 8.1과 프로그램 8.2를 수정하여 BinaryTree 클래스에서 구현했던 다음 멤버함수들을 BinaryNode 클래스에서 구현해라.
void BinaryNode::inorder();
void BinaryNode::preorder();
void BinaryNode::postorder();
int BinaryNode::getCount();
int BinaryNode::getHeight();
int BinaryNode::getLeafCount();
> 트리 & 이진탐색트리 - project02

순차탐색이란 정렬되지 않은 배열에서 탐색하고자 하는 숫자를 배열의 각 요소와
순차적으로 비교하여 탐색하는 방법을 말한다. 이진 탐색 트리의 성능을
일반배열에서의 순차 탐색과 비교해보자
(1)다음과 같은 순차 탐색 함수 sequentialSearch()를 작성한다
(2)프로그램이 시작되면 먼저 n개의 랜덤한 정수를 발생시켜 배열에 저장한다.
   가능한 평균적인 탐색 시간을 측정하기 위해 역시 랜덤한 수를 r개 발생시키고(r은 10 내외),
   각각을 배열에서 순차 탐색으로 찾고 실행시간을 측정한다. 이 때 반드시 탐색 연산에
   걸린 시간만을 측정해야하는 것에 주의한다. sequentialSearch() 함수의 호출전과 호출 후의 시각을
   저장하면 될 것이다. 탐색에 걸린 평균 시간을 계산한다. 같은 실험을 n이 10000부터 10000씩 증가시키면서
   반복한다.
(3) 동일한 실험을 이진탐색트리를 이용하여 반복한다. O(logn)이 O(n)보다 빠른 것을 보이면 된다.
> 트리 & 이진탐색트리 - project03

힙을 이용하지 않고 우선순위 큐를 작성하려고 한다.
정렬되지 않은 1차원 배열을 이용해 우선순위 큐 클래스
MaxPriorityQueue를 다음과 같이 작성한다.
> 우선순위큐 - ch01

배열로 표현된 완전 이진트리 a가 힙 조건을 만족하는지를 검사하는
다음 함수를 순환적인 방법으로 구현하고 테스트한다
> 우선순위큐 - ch02

3번 문제의 함수를 반복적인 방법으로 구현하고 테스트한다
> 우선순위큐 - ch03

(1)정점의 수와 간선의 수를 입력하면 무작위로 그래프를 발생시키는 함수를 구현하라.
단, 정점 사이에 중복된 간선이 존재하지 않아야 한다. 생성된 그래프를 화면에 출력하고, 파일에 저장하라.
정점의 이름은 'A'로부터 시작하여 하나씩 증가시키도록 한다.
(2) (1)을 이용하여 무작위로 그래프를 발생시키고 프로그램 11.13의 연결 성분 탐색을 참고하여 연결된 성분의 개수를 출력하라
(3) (1) 알고리즘을 보완하여 모든 정점이 연결된 "연결 그래프"를 무작위로 발생시키는 다음 함수를 구현한다.
    (2) 와 같이 연결된 성분의 개수가 1이 되는지 확인한다.
> 그래프 - project01

n개의 정점을 갖는 연결 그래프를 발생시키고 깊이 우선 탐색을 적용하여 정점을 방문하는 순서를 출력한다
> 그래프 - project02